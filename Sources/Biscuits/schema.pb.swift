/*
 * Copyright (c) 2025 Contributors to the Eclipse Foundation.
 * SPDX-License-Identifier: Apache-2.0
 */
// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: schema.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Biscuit_Format_Schema_Biscuit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rootKeyID: UInt32 {
    get {return _rootKeyID ?? 0}
    set {_rootKeyID = newValue}
  }
  /// Returns true if `rootKeyID` has been explicitly set.
  var hasRootKeyID: Bool {return self._rootKeyID != nil}
  /// Clears the value of `rootKeyID`. Subsequent reads from it will return its default value.
  mutating func clearRootKeyID() {self._rootKeyID = nil}

  var authority: Biscuit_Format_Schema_SignedBlock {
    get {return _authority ?? Biscuit_Format_Schema_SignedBlock()}
    set {_authority = newValue}
  }
  /// Returns true if `authority` has been explicitly set.
  var hasAuthority: Bool {return self._authority != nil}
  /// Clears the value of `authority`. Subsequent reads from it will return its default value.
  mutating func clearAuthority() {self._authority = nil}

  var blocks: [Biscuit_Format_Schema_SignedBlock] = []

  var proof: Biscuit_Format_Schema_Proof {
    get {return _proof ?? Biscuit_Format_Schema_Proof()}
    set {_proof = newValue}
  }
  /// Returns true if `proof` has been explicitly set.
  var hasProof: Bool {return self._proof != nil}
  /// Clears the value of `proof`. Subsequent reads from it will return its default value.
  mutating func clearProof() {self._proof = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rootKeyID: UInt32? = nil
  fileprivate var _authority: Biscuit_Format_Schema_SignedBlock? = nil
  fileprivate var _proof: Biscuit_Format_Schema_Proof? = nil
}

struct Biscuit_Format_Schema_SignedBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var block: Data {
    get {return _block ?? Data()}
    set {_block = newValue}
  }
  /// Returns true if `block` has been explicitly set.
  var hasBlock: Bool {return self._block != nil}
  /// Clears the value of `block`. Subsequent reads from it will return its default value.
  mutating func clearBlock() {self._block = nil}

  var nextKey: Biscuit_Format_Schema_PublicKey {
    get {return _nextKey ?? Biscuit_Format_Schema_PublicKey()}
    set {_nextKey = newValue}
  }
  /// Returns true if `nextKey` has been explicitly set.
  var hasNextKey: Bool {return self._nextKey != nil}
  /// Clears the value of `nextKey`. Subsequent reads from it will return its default value.
  mutating func clearNextKey() {self._nextKey = nil}

  var signature: Data {
    get {return _signature ?? Data()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {self._signature = nil}

  var externalSignature: Biscuit_Format_Schema_ExternalSignature {
    get {return _externalSignature ?? Biscuit_Format_Schema_ExternalSignature()}
    set {_externalSignature = newValue}
  }
  /// Returns true if `externalSignature` has been explicitly set.
  var hasExternalSignature: Bool {return self._externalSignature != nil}
  /// Clears the value of `externalSignature`. Subsequent reads from it will return its default value.
  mutating func clearExternalSignature() {self._externalSignature = nil}

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _block: Data? = nil
  fileprivate var _nextKey: Biscuit_Format_Schema_PublicKey? = nil
  fileprivate var _signature: Data? = nil
  fileprivate var _externalSignature: Biscuit_Format_Schema_ExternalSignature? = nil
  fileprivate var _version: UInt32? = nil
}

struct Biscuit_Format_Schema_ExternalSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var signature: Data {
    get {return _signature ?? Data()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {self._signature = nil}

  var publicKey: Biscuit_Format_Schema_PublicKey {
    get {return _publicKey ?? Biscuit_Format_Schema_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signature: Data? = nil
  fileprivate var _publicKey: Biscuit_Format_Schema_PublicKey? = nil
}

struct Biscuit_Format_Schema_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var algorithm: Biscuit_Format_Schema_PublicKey.Algorithm {
    get {return _algorithm ?? .ed25519}
    set {_algorithm = newValue}
  }
  /// Returns true if `algorithm` has been explicitly set.
  var hasAlgorithm: Bool {return self._algorithm != nil}
  /// Clears the value of `algorithm`. Subsequent reads from it will return its default value.
  mutating func clearAlgorithm() {self._algorithm = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Algorithm: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ed25519 // = 0
    case secp256R1 // = 1

    init() {
      self = .ed25519
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ed25519
      case 1: self = .secp256R1
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ed25519: return 0
      case .secp256R1: return 1
      }
    }

  }

  init() {}

  fileprivate var _algorithm: Biscuit_Format_Schema_PublicKey.Algorithm? = nil
  fileprivate var _key: Data? = nil
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_PublicKey.Algorithm: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_Proof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_Proof.OneOf_Content? = nil

  var nextSecret: Data {
    get {
      if case .nextSecret(let v)? = content {return v}
      return Data()
    }
    set {content = .nextSecret(newValue)}
  }

  var finalSignature: Data {
    get {
      if case .finalSignature(let v)? = content {return v}
      return Data()
    }
    set {content = .finalSignature(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case nextSecret(Data)
    case finalSignature(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_Proof.OneOf_Content, rhs: Biscuit_Format_Schema_Proof.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nextSecret, .nextSecret): return {
        guard case .nextSecret(let l) = lhs, case .nextSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalSignature, .finalSignature): return {
        guard case .finalSignature(let l) = lhs, case .finalSignature(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Biscuit_Format_Schema_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbols: [String] = []

  var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var factsV2: [Biscuit_Format_Schema_FactV2] = []

  var rulesV2: [Biscuit_Format_Schema_RuleV2] = []

  var checksV2: [Biscuit_Format_Schema_CheckV2] = []

  var scope: [Biscuit_Format_Schema_Scope] = []

  var publicKeys: [Biscuit_Format_Schema_PublicKey] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _context: String? = nil
  fileprivate var _version: UInt32? = nil
}

struct Biscuit_Format_Schema_Scope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_Scope.OneOf_Content? = nil

  var scopeType: Biscuit_Format_Schema_Scope.ScopeType {
    get {
      if case .scopeType(let v)? = content {return v}
      return .authority
    }
    set {content = .scopeType(newValue)}
  }

  var publicKey: Int64 {
    get {
      if case .publicKey(let v)? = content {return v}
      return 0
    }
    set {content = .publicKey(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case scopeType(Biscuit_Format_Schema_Scope.ScopeType)
    case publicKey(Int64)

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_Scope.OneOf_Content, rhs: Biscuit_Format_Schema_Scope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.scopeType, .scopeType): return {
        guard case .scopeType(let l) = lhs, case .scopeType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum ScopeType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case authority // = 0
    case previous // = 1

    init() {
      self = .authority
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .authority
      case 1: self = .previous
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .authority: return 0
      case .previous: return 1
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_Scope.ScopeType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_FactV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var predicate: Biscuit_Format_Schema_PredicateV2 {
    get {return _predicate ?? Biscuit_Format_Schema_PredicateV2()}
    set {_predicate = newValue}
  }
  /// Returns true if `predicate` has been explicitly set.
  var hasPredicate: Bool {return self._predicate != nil}
  /// Clears the value of `predicate`. Subsequent reads from it will return its default value.
  mutating func clearPredicate() {self._predicate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _predicate: Biscuit_Format_Schema_PredicateV2? = nil
}

struct Biscuit_Format_Schema_RuleV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var head: Biscuit_Format_Schema_PredicateV2 {
    get {return _head ?? Biscuit_Format_Schema_PredicateV2()}
    set {_head = newValue}
  }
  /// Returns true if `head` has been explicitly set.
  var hasHead: Bool {return self._head != nil}
  /// Clears the value of `head`. Subsequent reads from it will return its default value.
  mutating func clearHead() {self._head = nil}

  var body: [Biscuit_Format_Schema_PredicateV2] = []

  var expressions: [Biscuit_Format_Schema_ExpressionV2] = []

  var scope: [Biscuit_Format_Schema_Scope] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _head: Biscuit_Format_Schema_PredicateV2? = nil
}

struct Biscuit_Format_Schema_CheckV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var queries: [Biscuit_Format_Schema_RuleV2] = []

  var kind: Biscuit_Format_Schema_CheckV2.Kind {
    get {return _kind ?? .one}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case one // = 0
    case all // = 1
    case reject // = 2

    init() {
      self = .one
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .one
      case 1: self = .all
      case 2: self = .reject
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .one: return 0
      case .all: return 1
      case .reject: return 2
      }
    }

  }

  init() {}

  fileprivate var _kind: Biscuit_Format_Schema_CheckV2.Kind? = nil
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_CheckV2.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_PredicateV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: UInt64 {
    get {return _name ?? 0}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var terms: [Biscuit_Format_Schema_TermV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: UInt64? = nil
}

struct Biscuit_Format_Schema_TermV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_TermV2.OneOf_Content? = nil

  var variable: UInt32 {
    get {
      if case .variable(let v)? = content {return v}
      return 0
    }
    set {content = .variable(newValue)}
  }

  var integer: Int64 {
    get {
      if case .integer(let v)? = content {return v}
      return 0
    }
    set {content = .integer(newValue)}
  }

  var string: UInt64 {
    get {
      if case .string(let v)? = content {return v}
      return 0
    }
    set {content = .string(newValue)}
  }

  var date: UInt64 {
    get {
      if case .date(let v)? = content {return v}
      return 0
    }
    set {content = .date(newValue)}
  }

  var bytes: Data {
    get {
      if case .bytes(let v)? = content {return v}
      return Data()
    }
    set {content = .bytes(newValue)}
  }

  var bool: Bool {
    get {
      if case .bool(let v)? = content {return v}
      return false
    }
    set {content = .bool(newValue)}
  }

  var set: Biscuit_Format_Schema_TermSet {
    get {
      if case .set(let v)? = content {return v}
      return Biscuit_Format_Schema_TermSet()
    }
    set {content = .set(newValue)}
  }

  var null: Biscuit_Format_Schema_Empty {
    get {
      if case .null(let v)? = content {return v}
      return Biscuit_Format_Schema_Empty()
    }
    set {content = .null(newValue)}
  }

  var array: Biscuit_Format_Schema_Array {
    get {
      if case .array(let v)? = content {return v}
      return Biscuit_Format_Schema_Array()
    }
    set {content = .array(newValue)}
  }

  var map: Biscuit_Format_Schema_Map {
    get {
      if case .map(let v)? = content {return v}
      return Biscuit_Format_Schema_Map()
    }
    set {content = .map(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case variable(UInt32)
    case integer(Int64)
    case string(UInt64)
    case date(UInt64)
    case bytes(Data)
    case bool(Bool)
    case set(Biscuit_Format_Schema_TermSet)
    case null(Biscuit_Format_Schema_Empty)
    case array(Biscuit_Format_Schema_Array)
    case map(Biscuit_Format_Schema_Map)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .set: return {
        guard case .set(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .array: return {
        guard case .array(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .map: return {
        guard case .map(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_TermV2.OneOf_Content, rhs: Biscuit_Format_Schema_TermV2.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.variable, .variable): return {
        guard case .variable(let l) = lhs, case .variable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integer, .integer): return {
        guard case .integer(let l) = lhs, case .integer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.date, .date): return {
        guard case .date(let l) = lhs, case .date(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytes, .bytes): return {
        guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bool, .bool): return {
        guard case .bool(let l) = lhs, case .bool(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.null, .null): return {
        guard case .null(let l) = lhs, case .null(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.array, .array): return {
        guard case .array(let l) = lhs, case .array(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.map, .map): return {
        guard case .map(let l) = lhs, case .map(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Biscuit_Format_Schema_TermSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var set: [Biscuit_Format_Schema_TermV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_Array {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var array: [Biscuit_Format_Schema_TermV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_Map {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Biscuit_Format_Schema_MapEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_MapEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Biscuit_Format_Schema_MapKey {
    get {return _key ?? Biscuit_Format_Schema_MapKey()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: Biscuit_Format_Schema_TermV2 {
    get {return _value ?? Biscuit_Format_Schema_TermV2()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Biscuit_Format_Schema_MapKey? = nil
  fileprivate var _value: Biscuit_Format_Schema_TermV2? = nil
}

struct Biscuit_Format_Schema_MapKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_MapKey.OneOf_Content? = nil

  var integer: Int64 {
    get {
      if case .integer(let v)? = content {return v}
      return 0
    }
    set {content = .integer(newValue)}
  }

  var string: UInt64 {
    get {
      if case .string(let v)? = content {return v}
      return 0
    }
    set {content = .string(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case integer(Int64)
    case string(UInt64)

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_MapKey.OneOf_Content, rhs: Biscuit_Format_Schema_MapKey.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.integer, .integer): return {
        guard case .integer(let l) = lhs, case .integer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.string, .string): return {
        guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Biscuit_Format_Schema_ExpressionV2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ops: [Biscuit_Format_Schema_Op] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_Op {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_Op.OneOf_Content? = nil

  var value: Biscuit_Format_Schema_TermV2 {
    get {
      if case .value(let v)? = content {return v}
      return Biscuit_Format_Schema_TermV2()
    }
    set {content = .value(newValue)}
  }

  var unary: Biscuit_Format_Schema_OpUnary {
    get {
      if case .unary(let v)? = content {return v}
      return Biscuit_Format_Schema_OpUnary()
    }
    set {content = .unary(newValue)}
  }

  var binary: Biscuit_Format_Schema_OpBinary {
    get {
      if case .binary(let v)? = content {return v}
      return Biscuit_Format_Schema_OpBinary()
    }
    set {content = .binary(newValue)}
  }

  var closure: Biscuit_Format_Schema_OpClosure {
    get {
      if case .closure(let v)? = content {return v}
      return Biscuit_Format_Schema_OpClosure()
    }
    set {content = .closure(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case value(Biscuit_Format_Schema_TermV2)
    case unary(Biscuit_Format_Schema_OpUnary)
    case binary(Biscuit_Format_Schema_OpBinary)
    case closure(Biscuit_Format_Schema_OpClosure)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .value: return {
        guard case .value(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .unary: return {
        guard case .unary(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .binary: return {
        guard case .binary(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .closure: return {
        guard case .closure(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_Op.OneOf_Content, rhs: Biscuit_Format_Schema_Op.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unary, .unary): return {
        guard case .unary(let l) = lhs, case .unary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binary, .binary): return {
        guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.closure, .closure): return {
        guard case .closure(let l) = lhs, case .closure(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Biscuit_Format_Schema_OpUnary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Biscuit_Format_Schema_OpUnary.Kind {
    get {return _kind ?? .negate}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var ffiName: UInt64 {
    get {return _ffiName ?? 0}
    set {_ffiName = newValue}
  }
  /// Returns true if `ffiName` has been explicitly set.
  var hasFfiName: Bool {return self._ffiName != nil}
  /// Clears the value of `ffiName`. Subsequent reads from it will return its default value.
  mutating func clearFfiName() {self._ffiName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case negate // = 0
    case parens // = 1
    case length // = 2
    case typeOf // = 3
    case ffi // = 4

    init() {
      self = .negate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .negate
      case 1: self = .parens
      case 2: self = .length
      case 3: self = .typeOf
      case 4: self = .ffi
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .negate: return 0
      case .parens: return 1
      case .length: return 2
      case .typeOf: return 3
      case .ffi: return 4
      }
    }

  }

  init() {}

  fileprivate var _kind: Biscuit_Format_Schema_OpUnary.Kind? = nil
  fileprivate var _ffiName: UInt64? = nil
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_OpUnary.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_OpBinary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Biscuit_Format_Schema_OpBinary.Kind {
    get {return _kind ?? .lessThan}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var ffiName: UInt64 {
    get {return _ffiName ?? 0}
    set {_ffiName = newValue}
  }
  /// Returns true if `ffiName` has been explicitly set.
  var hasFfiName: Bool {return self._ffiName != nil}
  /// Clears the value of `ffiName`. Subsequent reads from it will return its default value.
  mutating func clearFfiName() {self._ffiName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case lessThan // = 0
    case greaterThan // = 1
    case lessOrEqual // = 2
    case greaterOrEqual // = 3
    case equal // = 4
    case contains // = 5
    case prefix // = 6
    case suffix // = 7
    case regex // = 8
    case add // = 9
    case sub // = 10
    case mul // = 11
    case div // = 12
    case and // = 13
    case or // = 14
    case intersection // = 15
    case union // = 16
    case bitwiseAnd // = 17
    case bitwiseOr // = 18
    case bitwiseXor // = 19
    case notEqual // = 20
    case heterogeneousEqual // = 21
    case heterogeneousNotEqual // = 22
    case lazyAnd // = 23
    case lazyOr // = 24
    case all // = 25
    case any // = 26
    case get // = 27
    case ffi // = 28
    case tryOr // = 29

    init() {
      self = .lessThan
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lessThan
      case 1: self = .greaterThan
      case 2: self = .lessOrEqual
      case 3: self = .greaterOrEqual
      case 4: self = .equal
      case 5: self = .contains
      case 6: self = .prefix
      case 7: self = .suffix
      case 8: self = .regex
      case 9: self = .add
      case 10: self = .sub
      case 11: self = .mul
      case 12: self = .div
      case 13: self = .and
      case 14: self = .or
      case 15: self = .intersection
      case 16: self = .union
      case 17: self = .bitwiseAnd
      case 18: self = .bitwiseOr
      case 19: self = .bitwiseXor
      case 20: self = .notEqual
      case 21: self = .heterogeneousEqual
      case 22: self = .heterogeneousNotEqual
      case 23: self = .lazyAnd
      case 24: self = .lazyOr
      case 25: self = .all
      case 26: self = .any
      case 27: self = .get
      case 28: self = .ffi
      case 29: self = .tryOr
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .lessThan: return 0
      case .greaterThan: return 1
      case .lessOrEqual: return 2
      case .greaterOrEqual: return 3
      case .equal: return 4
      case .contains: return 5
      case .prefix: return 6
      case .suffix: return 7
      case .regex: return 8
      case .add: return 9
      case .sub: return 10
      case .mul: return 11
      case .div: return 12
      case .and: return 13
      case .or: return 14
      case .intersection: return 15
      case .union: return 16
      case .bitwiseAnd: return 17
      case .bitwiseOr: return 18
      case .bitwiseXor: return 19
      case .notEqual: return 20
      case .heterogeneousEqual: return 21
      case .heterogeneousNotEqual: return 22
      case .lazyAnd: return 23
      case .lazyOr: return 24
      case .all: return 25
      case .any: return 26
      case .get: return 27
      case .ffi: return 28
      case .tryOr: return 29
      }
    }

  }

  init() {}

  fileprivate var _kind: Biscuit_Format_Schema_OpBinary.Kind? = nil
  fileprivate var _ffiName: UInt64? = nil
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_OpBinary.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_OpClosure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: [UInt32] = []

  var ops: [Biscuit_Format_Schema_Op] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var queries: [Biscuit_Format_Schema_RuleV2] = []

  var kind: Biscuit_Format_Schema_Policy.Kind {
    get {return _kind ?? .allow}
    set {_kind = newValue}
  }
  /// Returns true if `kind` has been explicitly set.
  var hasKind: Bool {return self._kind != nil}
  /// Clears the value of `kind`. Subsequent reads from it will return its default value.
  mutating func clearKind() {self._kind = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Kind: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case allow // = 0
    case deny // = 1

    init() {
      self = .allow
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allow
      case 1: self = .deny
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .allow: return 0
      case .deny: return 1
      }
    }

  }

  init() {}

  fileprivate var _kind: Biscuit_Format_Schema_Policy.Kind? = nil
}

#if swift(>=4.2)

extension Biscuit_Format_Schema_Policy.Kind: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Biscuit_Format_Schema_AuthorizerPolicies {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbols: [String] = []

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var facts: [Biscuit_Format_Schema_FactV2] = []

  var rules: [Biscuit_Format_Schema_RuleV2] = []

  var checks: [Biscuit_Format_Schema_CheckV2] = []

  var policies: [Biscuit_Format_Schema_Policy] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt32? = nil
}

struct Biscuit_Format_Schema_ThirdPartyBlockRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var legacyPreviousKey: Biscuit_Format_Schema_PublicKey {
    get {return _legacyPreviousKey ?? Biscuit_Format_Schema_PublicKey()}
    set {_legacyPreviousKey = newValue}
  }
  /// Returns true if `legacyPreviousKey` has been explicitly set.
  var hasLegacyPreviousKey: Bool {return self._legacyPreviousKey != nil}
  /// Clears the value of `legacyPreviousKey`. Subsequent reads from it will return its default value.
  mutating func clearLegacyPreviousKey() {self._legacyPreviousKey = nil}

  var legacyPublicKeys: [Biscuit_Format_Schema_PublicKey] = []

  var previousSignature: Data {
    get {return _previousSignature ?? Data()}
    set {_previousSignature = newValue}
  }
  /// Returns true if `previousSignature` has been explicitly set.
  var hasPreviousSignature: Bool {return self._previousSignature != nil}
  /// Clears the value of `previousSignature`. Subsequent reads from it will return its default value.
  mutating func clearPreviousSignature() {self._previousSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _legacyPreviousKey: Biscuit_Format_Schema_PublicKey? = nil
  fileprivate var _previousSignature: Data? = nil
}

struct Biscuit_Format_Schema_ThirdPartyBlockContents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Data {
    get {return _payload ?? Data()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var externalSignature: Biscuit_Format_Schema_ExternalSignature {
    get {return _externalSignature ?? Biscuit_Format_Schema_ExternalSignature()}
    set {_externalSignature = newValue}
  }
  /// Returns true if `externalSignature` has been explicitly set.
  var hasExternalSignature: Bool {return self._externalSignature != nil}
  /// Clears the value of `externalSignature`. Subsequent reads from it will return its default value.
  mutating func clearExternalSignature() {self._externalSignature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Data? = nil
  fileprivate var _externalSignature: Biscuit_Format_Schema_ExternalSignature? = nil
}

struct Biscuit_Format_Schema_AuthorizerSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var limits: Biscuit_Format_Schema_RunLimits {
    get {return _storage._limits ?? Biscuit_Format_Schema_RunLimits()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  mutating func clearLimits() {_uniqueStorage()._limits = nil}

  var executionTime: UInt64 {
    get {return _storage._executionTime ?? 0}
    set {_uniqueStorage()._executionTime = newValue}
  }
  /// Returns true if `executionTime` has been explicitly set.
  var hasExecutionTime: Bool {return _storage._executionTime != nil}
  /// Clears the value of `executionTime`. Subsequent reads from it will return its default value.
  mutating func clearExecutionTime() {_uniqueStorage()._executionTime = nil}

  var world: Biscuit_Format_Schema_AuthorizerWorld {
    get {return _storage._world ?? Biscuit_Format_Schema_AuthorizerWorld()}
    set {_uniqueStorage()._world = newValue}
  }
  /// Returns true if `world` has been explicitly set.
  var hasWorld: Bool {return _storage._world != nil}
  /// Clears the value of `world`. Subsequent reads from it will return its default value.
  mutating func clearWorld() {_uniqueStorage()._world = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Biscuit_Format_Schema_RunLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxFacts: UInt64 {
    get {return _maxFacts ?? 0}
    set {_maxFacts = newValue}
  }
  /// Returns true if `maxFacts` has been explicitly set.
  var hasMaxFacts: Bool {return self._maxFacts != nil}
  /// Clears the value of `maxFacts`. Subsequent reads from it will return its default value.
  mutating func clearMaxFacts() {self._maxFacts = nil}

  var maxIterations: UInt64 {
    get {return _maxIterations ?? 0}
    set {_maxIterations = newValue}
  }
  /// Returns true if `maxIterations` has been explicitly set.
  var hasMaxIterations: Bool {return self._maxIterations != nil}
  /// Clears the value of `maxIterations`. Subsequent reads from it will return its default value.
  mutating func clearMaxIterations() {self._maxIterations = nil}

  var maxTime: UInt64 {
    get {return _maxTime ?? 0}
    set {_maxTime = newValue}
  }
  /// Returns true if `maxTime` has been explicitly set.
  var hasMaxTime: Bool {return self._maxTime != nil}
  /// Clears the value of `maxTime`. Subsequent reads from it will return its default value.
  mutating func clearMaxTime() {self._maxTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxFacts: UInt64? = nil
  fileprivate var _maxIterations: UInt64? = nil
  fileprivate var _maxTime: UInt64? = nil
}

struct Biscuit_Format_Schema_AuthorizerWorld {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var symbols: [String] = []

  var publicKeys: [Biscuit_Format_Schema_PublicKey] = []

  var blocks: [Biscuit_Format_Schema_SnapshotBlock] = []

  var authorizerBlock: Biscuit_Format_Schema_SnapshotBlock {
    get {return _authorizerBlock ?? Biscuit_Format_Schema_SnapshotBlock()}
    set {_authorizerBlock = newValue}
  }
  /// Returns true if `authorizerBlock` has been explicitly set.
  var hasAuthorizerBlock: Bool {return self._authorizerBlock != nil}
  /// Clears the value of `authorizerBlock`. Subsequent reads from it will return its default value.
  mutating func clearAuthorizerBlock() {self._authorizerBlock = nil}

  var authorizerPolicies: [Biscuit_Format_Schema_Policy] = []

  var generatedFacts: [Biscuit_Format_Schema_GeneratedFacts] = []

  var iterations: UInt64 {
    get {return _iterations ?? 0}
    set {_iterations = newValue}
  }
  /// Returns true if `iterations` has been explicitly set.
  var hasIterations: Bool {return self._iterations != nil}
  /// Clears the value of `iterations`. Subsequent reads from it will return its default value.
  mutating func clearIterations() {self._iterations = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt32? = nil
  fileprivate var _authorizerBlock: Biscuit_Format_Schema_SnapshotBlock? = nil
  fileprivate var _iterations: UInt64? = nil
}

struct Biscuit_Format_Schema_Origin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: Biscuit_Format_Schema_Origin.OneOf_Content? = nil

  var authorizer: Biscuit_Format_Schema_Empty {
    get {
      if case .authorizer(let v)? = content {return v}
      return Biscuit_Format_Schema_Empty()
    }
    set {content = .authorizer(newValue)}
  }

  var origin: UInt32 {
    get {
      if case .origin(let v)? = content {return v}
      return 0
    }
    set {content = .origin(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case authorizer(Biscuit_Format_Schema_Empty)
    case origin(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: Biscuit_Format_Schema_Origin.OneOf_Content, rhs: Biscuit_Format_Schema_Origin.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.authorizer, .authorizer): return {
        guard case .authorizer(let l) = lhs, case .authorizer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.origin, .origin): return {
        guard case .origin(let l) = lhs, case .origin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Biscuit_Format_Schema_Empty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_GeneratedFacts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var origins: [Biscuit_Format_Schema_Origin] = []

  var facts: [Biscuit_Format_Schema_FactV2] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Biscuit_Format_Schema_SnapshotBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var context: String {
    get {return _context ?? String()}
    set {_context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  var hasContext: Bool {return self._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  mutating func clearContext() {self._context = nil}

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var factsV2: [Biscuit_Format_Schema_FactV2] = []

  var rulesV2: [Biscuit_Format_Schema_RuleV2] = []

  var checksV2: [Biscuit_Format_Schema_CheckV2] = []

  var scope: [Biscuit_Format_Schema_Scope] = []

  var externalKey: Biscuit_Format_Schema_PublicKey {
    get {return _externalKey ?? Biscuit_Format_Schema_PublicKey()}
    set {_externalKey = newValue}
  }
  /// Returns true if `externalKey` has been explicitly set.
  var hasExternalKey: Bool {return self._externalKey != nil}
  /// Clears the value of `externalKey`. Subsequent reads from it will return its default value.
  mutating func clearExternalKey() {self._externalKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _context: String? = nil
  fileprivate var _version: UInt32? = nil
  fileprivate var _externalKey: Biscuit_Format_Schema_PublicKey? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Biscuit_Format_Schema_Biscuit: @unchecked Sendable {}
extension Biscuit_Format_Schema_SignedBlock: @unchecked Sendable {}
extension Biscuit_Format_Schema_ExternalSignature: @unchecked Sendable {}
extension Biscuit_Format_Schema_PublicKey: @unchecked Sendable {}
extension Biscuit_Format_Schema_PublicKey.Algorithm: @unchecked Sendable {}
extension Biscuit_Format_Schema_Proof: @unchecked Sendable {}
extension Biscuit_Format_Schema_Proof.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_Block: @unchecked Sendable {}
extension Biscuit_Format_Schema_Scope: @unchecked Sendable {}
extension Biscuit_Format_Schema_Scope.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_Scope.ScopeType: @unchecked Sendable {}
extension Biscuit_Format_Schema_FactV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_RuleV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_CheckV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_CheckV2.Kind: @unchecked Sendable {}
extension Biscuit_Format_Schema_PredicateV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_TermV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_TermV2.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_TermSet: @unchecked Sendable {}
extension Biscuit_Format_Schema_Array: @unchecked Sendable {}
extension Biscuit_Format_Schema_Map: @unchecked Sendable {}
extension Biscuit_Format_Schema_MapEntry: @unchecked Sendable {}
extension Biscuit_Format_Schema_MapKey: @unchecked Sendable {}
extension Biscuit_Format_Schema_MapKey.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_ExpressionV2: @unchecked Sendable {}
extension Biscuit_Format_Schema_Op: @unchecked Sendable {}
extension Biscuit_Format_Schema_Op.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_OpUnary: @unchecked Sendable {}
extension Biscuit_Format_Schema_OpUnary.Kind: @unchecked Sendable {}
extension Biscuit_Format_Schema_OpBinary: @unchecked Sendable {}
extension Biscuit_Format_Schema_OpBinary.Kind: @unchecked Sendable {}
extension Biscuit_Format_Schema_OpClosure: @unchecked Sendable {}
extension Biscuit_Format_Schema_Policy: @unchecked Sendable {}
extension Biscuit_Format_Schema_Policy.Kind: @unchecked Sendable {}
extension Biscuit_Format_Schema_AuthorizerPolicies: @unchecked Sendable {}
extension Biscuit_Format_Schema_ThirdPartyBlockRequest: @unchecked Sendable {}
extension Biscuit_Format_Schema_ThirdPartyBlockContents: @unchecked Sendable {}
extension Biscuit_Format_Schema_AuthorizerSnapshot: @unchecked Sendable {}
extension Biscuit_Format_Schema_RunLimits: @unchecked Sendable {}
extension Biscuit_Format_Schema_AuthorizerWorld: @unchecked Sendable {}
extension Biscuit_Format_Schema_Origin: @unchecked Sendable {}
extension Biscuit_Format_Schema_Origin.OneOf_Content: @unchecked Sendable {}
extension Biscuit_Format_Schema_Empty: @unchecked Sendable {}
extension Biscuit_Format_Schema_GeneratedFacts: @unchecked Sendable {}
extension Biscuit_Format_Schema_SnapshotBlock: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "biscuit.format.schema"

extension Biscuit_Format_Schema_Biscuit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Biscuit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootKeyId"),
    2: .same(proto: "authority"),
    3: .same(proto: "blocks"),
    4: .same(proto: "proof"),
  ]

  public var isInitialized: Bool {
    if self._authority == nil {return false}
    if self._proof == nil {return false}
    if let v = self._authority, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.blocks) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._rootKeyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authority) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._proof) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rootKeyID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 3)
    }
    try { if let v = self._proof {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Biscuit, rhs: Biscuit_Format_Schema_Biscuit) -> Bool {
    if lhs._rootKeyID != rhs._rootKeyID {return false}
    if lhs._authority != rhs._authority {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._proof != rhs._proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_SignedBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "block"),
    2: .same(proto: "nextKey"),
    3: .same(proto: "signature"),
    4: .same(proto: "externalSignature"),
    5: .same(proto: "version"),
  ]

  public var isInitialized: Bool {
    if self._block == nil {return false}
    if self._nextKey == nil {return false}
    if self._signature == nil {return false}
    if let v = self._nextKey, !v.isInitialized {return false}
    if let v = self._externalSignature, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._block) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nextKey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._externalSignature) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._block {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nextKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._externalSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_SignedBlock, rhs: Biscuit_Format_Schema_SignedBlock) -> Bool {
    if lhs._block != rhs._block {return false}
    if lhs._nextKey != rhs._nextKey {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs._externalSignature != rhs._externalSignature {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_ExternalSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExternalSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .same(proto: "publicKey"),
  ]

  public var isInitialized: Bool {
    if self._signature == nil {return false}
    if self._publicKey == nil {return false}
    if let v = self._publicKey, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_ExternalSignature, rhs: Biscuit_Format_Schema_ExternalSignature) -> Bool {
    if lhs._signature != rhs._signature {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "algorithm"),
    2: .same(proto: "key"),
  ]

  public var isInitialized: Bool {
    if self._algorithm == nil {return false}
    if self._key == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._algorithm) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._algorithm {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_PublicKey, rhs: Biscuit_Format_Schema_PublicKey) -> Bool {
    if lhs._algorithm != rhs._algorithm {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_PublicKey.Algorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Ed25519"),
    1: .same(proto: "SECP256R1"),
  ]
}

extension Biscuit_Format_Schema_Proof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nextSecret"),
    2: .same(proto: "finalSignature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .nextSecret(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .finalSignature(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .nextSecret?: try {
      guard case .nextSecret(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .finalSignature?: try {
      guard case .finalSignature(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Proof, rhs: Biscuit_Format_Schema_Proof) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbols"),
    2: .same(proto: "context"),
    3: .same(proto: "version"),
    4: .standard(proto: "facts_v2"),
    5: .standard(proto: "rules_v2"),
    6: .standard(proto: "checks_v2"),
    7: .same(proto: "scope"),
    8: .same(proto: "publicKeys"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.factsV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rulesV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.checksV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.publicKeys) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.factsV2) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.rulesV2) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.checksV2) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.scope) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.publicKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 1)
    }
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.factsV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.factsV2, fieldNumber: 4)
    }
    if !self.rulesV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rulesV2, fieldNumber: 5)
    }
    if !self.checksV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checksV2, fieldNumber: 6)
    }
    if !self.scope.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scope, fieldNumber: 7)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeys, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Block, rhs: Biscuit_Format_Schema_Block) -> Bool {
    if lhs.symbols != rhs.symbols {return false}
    if lhs._context != rhs._context {return false}
    if lhs._version != rhs._version {return false}
    if lhs.factsV2 != rhs.factsV2 {return false}
    if lhs.rulesV2 != rhs.rulesV2 {return false}
    if lhs.checksV2 != rhs.checksV2 {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scopeType"),
    2: .same(proto: "publicKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Biscuit_Format_Schema_Scope.ScopeType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .scopeType(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .publicKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .scopeType?: try {
      guard case .scopeType(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .publicKey?: try {
      guard case .publicKey(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Scope, rhs: Biscuit_Format_Schema_Scope) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Scope.ScopeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Authority"),
    1: .same(proto: "Previous"),
  ]
}

extension Biscuit_Format_Schema_FactV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FactV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "predicate"),
  ]

  public var isInitialized: Bool {
    if self._predicate == nil {return false}
    if let v = self._predicate, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._predicate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._predicate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_FactV2, rhs: Biscuit_Format_Schema_FactV2) -> Bool {
    if lhs._predicate != rhs._predicate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_RuleV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuleV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "head"),
    2: .same(proto: "body"),
    3: .same(proto: "expressions"),
    4: .same(proto: "scope"),
  ]

  public var isInitialized: Bool {
    if self._head == nil {return false}
    if let v = self._head, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.body) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.expressions) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._head) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.expressions) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._head {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 2)
    }
    if !self.expressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expressions, fieldNumber: 3)
    }
    if !self.scope.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scope, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_RuleV2, rhs: Biscuit_Format_Schema_RuleV2) -> Bool {
    if lhs._head != rhs._head {return false}
    if lhs.body != rhs.body {return false}
    if lhs.expressions != rhs.expressions {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_CheckV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
    2: .same(proto: "kind"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.queries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_CheckV2, rhs: Biscuit_Format_Schema_CheckV2) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_CheckV2.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "One"),
    1: .same(proto: "All"),
    2: .same(proto: "Reject"),
  ]
}

extension Biscuit_Format_Schema_PredicateV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PredicateV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "terms"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.terms) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.terms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if !self.terms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.terms, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_PredicateV2, rhs: Biscuit_Format_Schema_PredicateV2) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.terms != rhs.terms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_TermV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TermV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variable"),
    2: .same(proto: "integer"),
    3: .same(proto: "string"),
    4: .same(proto: "date"),
    5: .same(proto: "bytes"),
    6: .same(proto: "bool"),
    7: .same(proto: "set"),
    8: .same(proto: "null"),
    9: .same(proto: "array"),
    10: .same(proto: "map"),
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .variable(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .integer(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .string(v)
        }
      }()
      case 4: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .date(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .bytes(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .bool(v)
        }
      }()
      case 7: try {
        var v: Biscuit_Format_Schema_TermSet?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .set(v)
        }
      }()
      case 8: try {
        var v: Biscuit_Format_Schema_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .null(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .null(v)
        }
      }()
      case 9: try {
        var v: Biscuit_Format_Schema_Array?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .array(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .array(v)
        }
      }()
      case 10: try {
        var v: Biscuit_Format_Schema_Map?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .map(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .map(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .variable?: try {
      guard case .variable(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    }()
    case .integer?: try {
      guard case .integer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .string?: try {
      guard case .string(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case .date?: try {
      guard case .date(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }()
    case .bytes?: try {
      guard case .bytes(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .bool?: try {
      guard case .bool(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case .set?: try {
      guard case .set(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .null?: try {
      guard case .null(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .array?: try {
      guard case .array(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .map?: try {
      guard case .map(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_TermV2, rhs: Biscuit_Format_Schema_TermV2) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_TermSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TermSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.set) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.set) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.set.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.set, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_TermSet, rhs: Biscuit_Format_Schema_TermSet) -> Bool {
    if lhs.set != rhs.set {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Array: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Array"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "array"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.array) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.array) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.array.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.array, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Array, rhs: Biscuit_Format_Schema_Array) -> Bool {
    if lhs.array != rhs.array {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Map: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Map"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Map, rhs: Biscuit_Format_Schema_Map) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_MapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_MapEntry, rhs: Biscuit_Format_Schema_MapEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_MapKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "integer"),
    2: .same(proto: "string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .integer(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .string(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .integer?: try {
      guard case .integer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 1)
    }()
    case .string?: try {
      guard case .string(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_MapKey, rhs: Biscuit_Format_Schema_MapKey) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_ExpressionV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExpressionV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ops"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ops) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_ExpressionV2, rhs: Biscuit_Format_Schema_ExpressionV2) -> Bool {
    if lhs.ops != rhs.ops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Op: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Op"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "unary"),
    3: .same(proto: "Binary"),
    4: .same(proto: "closure"),
  ]

  public var isInitialized: Bool {
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Biscuit_Format_Schema_TermV2?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .value(v)
        }
      }()
      case 2: try {
        var v: Biscuit_Format_Schema_OpUnary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .unary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .unary(v)
        }
      }()
      case 3: try {
        var v: Biscuit_Format_Schema_OpBinary?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .binary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .binary(v)
        }
      }()
      case 4: try {
        var v: Biscuit_Format_Schema_OpClosure?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .closure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .closure(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .value?: try {
      guard case .value(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unary?: try {
      guard case .unary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .closure?: try {
      guard case .closure(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Op, rhs: Biscuit_Format_Schema_Op) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_OpUnary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpUnary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "ffiName"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._ffiName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ffiName {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_OpUnary, rhs: Biscuit_Format_Schema_OpUnary) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._ffiName != rhs._ffiName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_OpUnary.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Negate"),
    1: .same(proto: "Parens"),
    2: .same(proto: "Length"),
    3: .same(proto: "TypeOf"),
    4: .same(proto: "Ffi"),
  ]
}

extension Biscuit_Format_Schema_OpBinary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpBinary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "ffiName"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._ffiName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ffiName {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_OpBinary, rhs: Biscuit_Format_Schema_OpBinary) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._ffiName != rhs._ffiName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_OpBinary.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LessThan"),
    1: .same(proto: "GreaterThan"),
    2: .same(proto: "LessOrEqual"),
    3: .same(proto: "GreaterOrEqual"),
    4: .same(proto: "Equal"),
    5: .same(proto: "Contains"),
    6: .same(proto: "Prefix"),
    7: .same(proto: "Suffix"),
    8: .same(proto: "Regex"),
    9: .same(proto: "Add"),
    10: .same(proto: "Sub"),
    11: .same(proto: "Mul"),
    12: .same(proto: "Div"),
    13: .same(proto: "And"),
    14: .same(proto: "Or"),
    15: .same(proto: "Intersection"),
    16: .same(proto: "Union"),
    17: .same(proto: "BitwiseAnd"),
    18: .same(proto: "BitwiseOr"),
    19: .same(proto: "BitwiseXor"),
    20: .same(proto: "NotEqual"),
    21: .same(proto: "HeterogeneousEqual"),
    22: .same(proto: "HeterogeneousNotEqual"),
    23: .same(proto: "LazyAnd"),
    24: .same(proto: "LazyOr"),
    25: .same(proto: "All"),
    26: .same(proto: "Any"),
    27: .same(proto: "Get"),
    28: .same(proto: "Ffi"),
    29: .same(proto: "TryOr"),
  ]
}

extension Biscuit_Format_Schema_OpClosure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OpClosure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "ops"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.ops) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.params) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ops) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.params.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.params, fieldNumber: 1)
    }
    if !self.ops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ops, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_OpClosure, rhs: Biscuit_Format_Schema_OpClosure) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.ops != rhs.ops {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Policy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
    2: .same(proto: "kind"),
  ]

  public var isInitialized: Bool {
    if self._kind == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.queries) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queries) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.queries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queries, fieldNumber: 1)
    }
    try { if let v = self._kind {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Policy, rhs: Biscuit_Format_Schema_Policy) -> Bool {
    if lhs.queries != rhs.queries {return false}
    if lhs._kind != rhs._kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Policy.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Allow"),
    1: .same(proto: "Deny"),
  ]
}

extension Biscuit_Format_Schema_AuthorizerPolicies: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizerPolicies"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbols"),
    2: .same(proto: "version"),
    3: .same(proto: "facts"),
    4: .same(proto: "rules"),
    5: .same(proto: "checks"),
    6: .same(proto: "policies"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.facts) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rules) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.checks) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.policies) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.facts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.checks) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.policies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 1)
    }
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.facts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.facts, fieldNumber: 3)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 4)
    }
    if !self.checks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checks, fieldNumber: 5)
    }
    if !self.policies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.policies, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_AuthorizerPolicies, rhs: Biscuit_Format_Schema_AuthorizerPolicies) -> Bool {
    if lhs.symbols != rhs.symbols {return false}
    if lhs._version != rhs._version {return false}
    if lhs.facts != rhs.facts {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.checks != rhs.checks {return false}
    if lhs.policies != rhs.policies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_ThirdPartyBlockRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThirdPartyBlockRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "legacyPreviousKey"),
    2: .same(proto: "legacyPublicKeys"),
    3: .same(proto: "previousSignature"),
  ]

  public var isInitialized: Bool {
    if self._previousSignature == nil {return false}
    if let v = self._legacyPreviousKey, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.legacyPublicKeys) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._legacyPreviousKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.legacyPublicKeys) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._previousSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._legacyPreviousKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.legacyPublicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.legacyPublicKeys, fieldNumber: 2)
    }
    try { if let v = self._previousSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_ThirdPartyBlockRequest, rhs: Biscuit_Format_Schema_ThirdPartyBlockRequest) -> Bool {
    if lhs._legacyPreviousKey != rhs._legacyPreviousKey {return false}
    if lhs.legacyPublicKeys != rhs.legacyPublicKeys {return false}
    if lhs._previousSignature != rhs._previousSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_ThirdPartyBlockContents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThirdPartyBlockContents"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "externalSignature"),
  ]

  public var isInitialized: Bool {
    if self._payload == nil {return false}
    if self._externalSignature == nil {return false}
    if let v = self._externalSignature, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._externalSignature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._externalSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_ThirdPartyBlockContents, rhs: Biscuit_Format_Schema_ThirdPartyBlockContents) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs._externalSignature != rhs._externalSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_AuthorizerSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizerSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limits"),
    2: .same(proto: "executionTime"),
    3: .same(proto: "world"),
  ]

  fileprivate class _StorageClass {
    var _limits: Biscuit_Format_Schema_RunLimits? = nil
    var _executionTime: UInt64? = nil
    var _world: Biscuit_Format_Schema_AuthorizerWorld? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _limits = source._limits
      _executionTime = source._executionTime
      _world = source._world
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._limits == nil {return false}
      if _storage._executionTime == nil {return false}
      if _storage._world == nil {return false}
      if let v = _storage._limits, !v.isInitialized {return false}
      if let v = _storage._world, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._limits) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._executionTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._world) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._executionTime {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._world {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_AuthorizerSnapshot, rhs: Biscuit_Format_Schema_AuthorizerSnapshot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._executionTime != rhs_storage._executionTime {return false}
        if _storage._world != rhs_storage._world {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_RunLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RunLimits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "maxFacts"),
    2: .same(proto: "maxIterations"),
    3: .same(proto: "maxTime"),
  ]

  public var isInitialized: Bool {
    if self._maxFacts == nil {return false}
    if self._maxIterations == nil {return false}
    if self._maxTime == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._maxFacts) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._maxIterations) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxFacts {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxIterations {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_RunLimits, rhs: Biscuit_Format_Schema_RunLimits) -> Bool {
    if lhs._maxFacts != rhs._maxFacts {return false}
    if lhs._maxIterations != rhs._maxIterations {return false}
    if lhs._maxTime != rhs._maxTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_AuthorizerWorld: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizerWorld"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "symbols"),
    3: .same(proto: "publicKeys"),
    4: .same(proto: "blocks"),
    5: .same(proto: "authorizerBlock"),
    6: .same(proto: "authorizerPolicies"),
    7: .same(proto: "generatedFacts"),
    8: .same(proto: "iterations"),
  ]

  public var isInitialized: Bool {
    if self._authorizerBlock == nil {return false}
    if self._iterations == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.publicKeys) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.blocks) {return false}
    if let v = self._authorizerBlock, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.authorizerPolicies) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.generatedFacts) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.symbols) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.publicKeys) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._authorizerBlock) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.authorizerPolicies) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.generatedFacts) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._iterations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.symbols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.symbols, fieldNumber: 2)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeys, fieldNumber: 3)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 4)
    }
    try { if let v = self._authorizerBlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.authorizerPolicies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.authorizerPolicies, fieldNumber: 6)
    }
    if !self.generatedFacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.generatedFacts, fieldNumber: 7)
    }
    try { if let v = self._iterations {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_AuthorizerWorld, rhs: Biscuit_Format_Schema_AuthorizerWorld) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs.symbols != rhs.symbols {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs._authorizerBlock != rhs._authorizerBlock {return false}
    if lhs.authorizerPolicies != rhs.authorizerPolicies {return false}
    if lhs.generatedFacts != rhs.generatedFacts {return false}
    if lhs._iterations != rhs._iterations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Origin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Origin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authorizer"),
    2: .same(proto: "origin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Biscuit_Format_Schema_Empty?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .authorizer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .authorizer(v)
        }
      }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .origin(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .authorizer?: try {
      guard case .authorizer(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .origin?: try {
      guard case .origin(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Origin, rhs: Biscuit_Format_Schema_Origin) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Empty"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_Empty, rhs: Biscuit_Format_Schema_Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_GeneratedFacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GeneratedFacts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origins"),
    2: .same(proto: "facts"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.facts) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.origins) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.facts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.origins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.origins, fieldNumber: 1)
    }
    if !self.facts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.facts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_GeneratedFacts, rhs: Biscuit_Format_Schema_GeneratedFacts) -> Bool {
    if lhs.origins != rhs.origins {return false}
    if lhs.facts != rhs.facts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Biscuit_Format_Schema_SnapshotBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SnapshotBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
    2: .same(proto: "version"),
    3: .standard(proto: "facts_v2"),
    4: .standard(proto: "rules_v2"),
    5: .standard(proto: "checks_v2"),
    6: .same(proto: "scope"),
    7: .same(proto: "externalKey"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.factsV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.rulesV2) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.checksV2) {return false}
    if let v = self._externalKey, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._context) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.factsV2) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rulesV2) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.checksV2) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.scope) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._externalKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._context {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.factsV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.factsV2, fieldNumber: 3)
    }
    if !self.rulesV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rulesV2, fieldNumber: 4)
    }
    if !self.checksV2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.checksV2, fieldNumber: 5)
    }
    if !self.scope.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scope, fieldNumber: 6)
    }
    try { if let v = self._externalKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Biscuit_Format_Schema_SnapshotBlock, rhs: Biscuit_Format_Schema_SnapshotBlock) -> Bool {
    if lhs._context != rhs._context {return false}
    if lhs._version != rhs._version {return false}
    if lhs.factsV2 != rhs.factsV2 {return false}
    if lhs.rulesV2 != rhs.rulesV2 {return false}
    if lhs.checksV2 != rhs.checksV2 {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs._externalKey != rhs._externalKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
